
#pragma once

#include "tt/path/dirs.hpp"

namespace tt {

class SystemDirs : public Dirs {
public:
    [[nodiscard]] auto bindir() const -> std::filesystem::path override {
        return "@bindir@";
    }

    [[nodiscard]] auto confdir() const -> std::filesystem::path override {
        return "@confdir@";
    }

    [[nodiscard]] auto libexecdir() const -> std::filesystem::path override {
        return "@libexecdir@";
    }

    [[nodiscard]] auto livedir() const -> std::filesystem::path override {
        return "@livedir@";
    }

    [[nodiscard]] auto logdir() const -> std::filesystem::path override {
        return "@logdir@";
    }

    [[nodiscard]] auto servicedirs() const
        -> std::vector<std::filesystem::path> override {
        // confdir will be overridden by UserDirs. By calling confdir we might
        // call UserDirs::confdir which is not what we want
        return {AppendServiceDirectory(SystemDirs::confdir()), "@servicedir@"};
    }

    [[nodiscard]] auto statedir() const -> std::filesystem::path override {
        return "@statedir@";
    }

    [[nodiscard]] auto supervisedir() const -> std::filesystem::path override {
        // Same as servicedirs()
        auto dir = AppendSuperviseDirectory(SystemDirs::livedir());
        std::filesystem::create_directories(dir);
        return dir;
    }

protected:
    [[nodiscard]] static auto
    AppendServiceDirectory(const std::filesystem::path &path)
        -> std::filesystem::path {
        return path / "service";
    }

    [[nodiscard]] static auto
    AppendSuperviseDirectory(const std::filesystem::path &path)
        -> std::filesystem::path {
        return path / "supervise";
    }
};

} // namespace tt
